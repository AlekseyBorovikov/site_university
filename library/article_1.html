<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Библиотека</title>
		<link rel="stylesheet" type="text/css" href="../css/style.css">
		<link rel="stylesheet" type="text/css" href="../css/image_style.css">
		<link rel="stylesheet" type="text/css" href="../css/font-style.css">
		<link rel="stylesheet" type="text/css" href="../css/layout-style.css">
		<link rel="stylesheet" type="text/css" href="../css/dimens.css">
		<link rel="stylesheet" type="text/css" href="../css/colors.css">
		<script src="../components/main_inform.js" type="text/javascript" defer></script>
		<script src="../components/header.js" type="text/javascript" defer></script>
		<script src="../components/menu.js" type="text/javascript" defer></script>
		<script src="../components/footer.js" type="text/javascript" defer></script>
	</head>

	<body>
 
 		<div class="back_button"><a href="index.html">&#10094; Назад в библиотеку</a></div>
		
		<main class="flex-center">

			<article>

				<div class="flex-center">
					<div>
						<h2 id="text-align-center">ОПТИМИЗАЦИЯ И ПОВЫШЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ ИГРОВЫХ ДВИЖКОВ ДЛЯ ANDROID</h2>
						<p id="text-align-center"><b>Боровиков  А.И.*1, Зори С. А.*2</b></p>
						<p id="text-align-center">*1 магистр кафедры программной инженерии им. Л.П. Фельдмана, Донецкий национальный технический университет,</p>
						<p id="text-align-center">aleksey.borovikov.00@mail.ru, SPIN-код: 2472-1006</p>
						<p id="text-align-center">*2 д.т.н., проф. кафедры программной инженерии им. Л.П. Фельдмана, Донецкий национальный технический университет,</p>
						<p id="text-align-center">ik.ivt.rec@mail.ru, OrcID: 0000-0003-4018-234X, SPIN-код: 3565-6330</p>
					</div>
				</div>
				<h2 id="tab">&emsp;Аннотация</h2>
				<p id="tab">&emsp;<b>Зори С.А., Боровиков А.И. Оптимизация и повышение производительности игровых движков для android.</b> В статье представлен анализ влияния производительности игры на «комфорт» для пользователей, проведён анализ возможных проблем оптимизации движка, тонкостей языка программирования java, которые могут повлиять на производительность и особенности написания игр под мобильные приложения. В дальнейших исследованиях планируется проверить на практике приведённые методы и представить метрики в виде графиков и диаграмм с целью их усовершенствования.</p>
				<p id="tab">&emsp;<b>Ключевые слова:</b> Java, CPU, GPU, fps, время простоя процессора, циклы, потоки, память, рендер, Vulkan, тепловая нагрузка, энергопотребление, OpenGL, libGDX, JVM GC.</p><br/>
				<p id="tab">&emsp;<b>Abstract: </b>the article deals with the problems of optimization of mobile android-games based on the game engine «Unity» on the example of the Yakut company «Andi Games» (SP Sotieva Vs) Description of the optimization process from different angles.</p>
				<h2>Введение</h2>
				<p>&emsp;Производительность является важным компонентом любой игры, от неё зависит популярность игры, комфорт пользователя и общее впечатление. Под производительностью обычно подразумевают средний уровень FPS в игре за определённый промежуток времени.  FPS (Frame Per Second) - число кадров в секунду, кадры - это изображения, которые обрабатывает графический адаптер по команде центрального процессора. Чем больше кадров демонстрируется в секунду, тем плавнее и комфортнее игра [1].</p>
				<p>&emsp;Вопреки ожиданиям немногие игроки требуют высоких показателей фпс, для большинства достаточно средних показателей в 30 единиц, а для некоторых даже меньше. Исследования проделанные компанией Lesta Studio [2], показывают, что для всей совокупности пользователей связь между производительностью и комфортной игрой достаточно слабая (рис.1).</p>

				<div class="image_container flex-center">
					<img src="../images/comfort_fps.png" class="responsive_image_80 flex-center">
				</div>
				<p id="image_description">Рисунок 1 – Диаграмма зависимости между восприятием комфорта и средним FPS</p>


				<p>&emsp;Однако уровень комфорта зависит так же от жанра игры и от самого пользователя. Например, многие консольные игры работают на частоте 30fps, но с такими показателями картинка недостаточно плавная, а отзыв на манипуляции игрока запаздывает, что мешает полному погружению в игру. Для игроков в казуально -аркадные игры будет достаточно 40+fps, для шутеров от первого лица, стратегий, ритм-игр, MOBA понадобится около 60-100fps. Показатель Fps выше 100 потребуется игрокам соревновательных шутеров или киберспортсменов.</p>
				<p>&emsp;Таким образом, если не брать во внимание предпочтения в fps профессиональных игроков, то для большинства будет комфортным средний показатель в 60fps, этот показатель считается комфортным минимумом.</p><br/>

				<h2>Влияние на производительность</h2>
				<p>&emsp;На производительность игры влияет следующее:</p>
				<ul class="clear">
					<li><p>1. Клиентское ПО, включая ОС. Если система загружена фоновыми процессами или запущены программы, обращающиеся к диску во время игры, то ресурсов для самой игры может оказаться недостаточно.</li>
					<li><p>2. Конфигурация ПК. От комплектующих компьютера напрямую зависит производительность.</p></li>
					<li><p>3. Настройки графики. Графику настраивают пользователи обычно сами или используют пресеты, однако ни тот ни другой вариант не являются гарантией того, что настройки будут выставлены максимально оптимально, из-за чего пользователь теряет производительность.</p></li>
					<li><p>4. Сетевые проблемы. Клиент-серверное взаимодействие не всегда устойчиво, нередко у пользователей возникают проблемы с сетью, что влияет на производительность сетевых игр. Причиной этому могут послужить проблемы на стороне провайдера, большое количество беспроводных клиентов неоптимальный сетевой маршрут доставки трафика, некачественной сетевое оборудование.</p></li>
					<li><p>5. Модификации. Модификации оригинальной игры сторонними разрабочиками отрицательно влияют на производительность. Они не только снижают средний fps, но и создают резкие провалы в тех случаях, где чистый клиент работает стабильно.</p></li>
					<li><p>6. Скорость работы приложения. Существует огромное количество разных игровых движков со своими плюсами и минусами, все они потребляют разное количество ресурсов, в зависимости от качества архитектуры и поддерживаемых эффектов. Влияет так же и язык программирования, на котором написан движок, т.к. в разных языках ресурсы распределяются по разному. Об этом и пойдёт речь дальше.</p></li>
				</ul><br/>

				<h2>Способы оптимизации кода</h2>
				<p>&emsp;Для того, чтоб движок выдавал максимальное количество fps необходимо не только уметь с ним эффективно работать, но и знать тонкости разработки на языке, на котором написан движок, и принципы работы движка для лучшего понимания процесса распределения ресурсов [3].</p>
				<p>&emsp;Существует много разных факторов, влияющих на скорость обработки кадров, рассмотрим общие методы оптимизации кода. Которые могут подойти практически в любой ситуации:</p>
				<ul class="clear">
					<li><p>1. Минимизация влияния объектов за пределами экрана. Минимизация объёма вычислений при помощи оптимизации отрисовки объектов чрезвычайно важна. Зачастую этим занимаются движки, или же графический процессор. Для реализации необходимо разделить объект на 2 слоя - первый будет графическим представлением объекта, а второй - данными и функциями. Таким образом, если объект находится за пределами экрана - нам больше не нужно его отрисовывать.</li>
					<li><p>2. Независимость от обновления кадров. Обычно в игровых движках боьшинство объектов обновляются в каждом кадре, это сильно нагружает процессор и понижает производительность. Необходимо, по возможности, избавиться от обновлния в каждом кадре. Для этого необходимо отделить функцию рендеринга и вызывать её только при изменении состояния объекта.</p></li>
					<li><p>3. 3.Непосредственные вычисления и поиск значений. Неплохую прибавку к производительности может дать хеширование тригонометрических функций, т.к. эффективнее хранить большую таблицу и брать данные из неё, а не выполнять расчёты на лету.</p></li>
					<li><p>4. 4.Использование времени простоя процессора. Необходимо выделить функции, которые не зависят от времени, например погодные условия и вычислять их, когда пользователь отошёл, занят чтением или другими не затратными к ресурсами вещами. Время которое освобождается, когда пользователь занят вещами не нагружающими процессор, можно использовать для вычисления множества других событий.</p></li>
				</ul><br/>

				<h2>Оптимизация движка на основе языка java</h2>
				<p>&emsp;Так же не лишним будет упомянуть оптимизацию кода, опираясь на особенности языка программирования java и особенности работы с движками на его основе [4];</p>
				<ul class="clear">
					<li><p>1. Циклы. Если вам необходимо обойти большой массив дааных, например список прямоугольников (для рендеринга), врагов или любых других тяжелых объектов и вы собираетесь для этого использовать цикл for, то лучше пользовться обратным for. Обратный for даёт большую эффективность за счёт того, что ему не нужно каждый раз проверять размер массива, а также это происходит, потому что сравнение с нулем является нормальным, в то время как сравнение с целым числом требует вычитания. Но если нет необходимоссти использовать цикл for, то более эффективным будет while.</li>
					<li><p>2. Потоки. Необходимо разделять тяжелые действия на разне потоки и не запускть сложную логику в потоке отрисовки. При профилировании ЦП вы увидите поток с именем GLThread. Большинство движков используют GL 2.0/3.0 для рендеринга, и это поток, который содержит контекст GL. Это означает, что каждое изменение пользовательского интерфейса должно производиться через этот поток, иначе случаются плохие вещи — текстуры не загружаются, элементы пользовательского интерфейса меняются одновременно из разных мест, это может быть беспорядок. Проблема в том, что использование этого потока оставляет пользователя с зависшим приложением.</p></li>
					<li><p>3. Память. Не стоит забывать очищать компоненты, которые уже не нужны. Java имеет свой сборщик мусора, который чистит ненужные классы, но некоторые движки, например libGDX, этого не делает. Это связано с тем, что память OpenGL не управляется JVM GC, и, таким образом, если вы создаете свои собственные текстуры, вам придется удалять их вручную, иначе вы рискуете трудно отлаживаемой утечкой памяти.</p></li>
					<li><p>4. Пакеты. Вызов начала и конца пакета спрайтов и ShapeRenderer занимает много памяти. Итак, старайтесь изо всех сил вызывать начало и конец только один раз за кадр. Попробуйте визуализировать все свои спрайты, а затем визуализировать фигуры. Вместо того, чтобы рендерить ваши спрайты, затем формы, а затем повторно открывая ваш spritebatch.</p></li>
					<li><p>5. Избегайте некоторых методов: Есть некоторые методы, которые требуют много ресурсов (или больше, чем другие), когда они используются, например пересечения класса Rectangle. Например, лучшее, что вы можете сделать для просмотра массива прямоугольников, — это сначала проверить, близки ли оба прямоугольника, и если да, то вызвать для них метод Intersects. Вместо вызова Intersects со всеми прямоугольниками в массиве.</p></li>
					<li><p>6. Визуализация. Метод рисования — это еще один элемент, который требует большого количества ресурсов, если вам нужно изменить состояние элемента, даже если он находится за пределами экрана, вы можете каждый раз пытаться обновлять его логику/переменные, но вызывать метод рисования только если он находится внутри координат экрана.</p></li>
					<li><p>7. Переменные. объявление переменных или объектов в плохих местах может вызвать зависание, избегайте объявления переменных в цикле рендеринга и, в основном, не объявляйте их внутри чего-то вроде цикла for, вместо этого объявляйте их вне цикла и обновляйте его значения внутри. Хороший момент в этом, заключается в том, что это не имеет значения, когда мы говорим о примитивных типах данных, поэтому, если переменная имеет тип int, boolean или float, ее объявление внутри цикла не окажет большого влияния на производительность.</p></li>
					<li><p>8. Паттерны. Паттерны значительно упрощают разработку и эффективность приложение, а так же поддержку кода. Если вы хотите иметь один элемент, который может взаимодействовать и находиться в любом классе вашей программы, что-то вездесущее, например класс игрока, вы можете сделать его классом Singleton (это очень просто и даст вам более удобный код). Если вы не хотите, чтобы в вашей программе были бесполезные экземпляры, которые, возможно, вы никогда не будете использовать, вы можете использовать шаблон проектирования Factory.</p></li>
				</ul><br/>

				<h2>Оптимизация игр для смартфонов [5]</h2>
				<ul class="clear">
					<li><p>1. 1.Скорость загрузки. Игроки хотят как можно быстрее погрузиться в действие вашей игры, поэтому важно максимально сократить время загрузки вашей игры . Следующие меры обычно помогают сократить время загрузки:</li>
						<ul class="clear sublevel2">
							<li><p>– Выполнить ленивую загрузку. Если вы используете одни и те же assets в последовательных сценах или уровнях игры, загружайте эти assets только один раз;</p></li>
							<li><p>– Уменьшите размер своих assets. Таким образом, вы можете связать несжатые версии этих ресурсов с APK вашей игры;</p></li>
							<li><p>– Используйте эффективный для диска метод сжатия. Примером такого метода является zlib.</p></li>
						</ul>
					<li><p>2. Необходимо держать потоки с большим объемом памяти на одном процессоре. На многих мобильных устройствах кэши L1 находятся на определенных ЦП, а кэши L2 — на наборе ЦП, которые имеют общие часы. Чтобы максимизировать попадание в кэш L1, как правило, лучше всего, чтобы основной поток вашей игры, наряду с любыми другими потоками с большим объемом памяти, выполнялся на одном процессоре;</p></li>
					<li><p>3. Необходимо откладывать кратковременную работу на процессоры с меньшей мощностью. Большинство игровых движков умеют откладывать операции рабочего потока на другой ЦП по сравнению с основным потоком вашей игры. Однако движок не знает о конкретной архитектуре устройства и не может предвидеть рабочую нагрузку вашей игры так же хорошо, как вы. Большинство устройств типа «система на кристалле» имеют как минимум 2 общих тактовых генератора. один для быстрых процессоров устройства и один для медленных процессоров устройства. Следствием этой архитектуры является то, что если одному быстрому ЦП необходимо работать на максимальной скорости, все остальные быстрые ЦП также работают на максимальной скорости. В примере отчета, показанном на рис. 2, показана игра, использующая преимущества быстрых процессоров [6]. Однако, этот высокий уровень активности быстро генерирует большое количество энергии и тепла.</p>

						<div class="image_container flex-center">
							<img src="../images/cpu_report.svg" class="responsive_image_80 flex-center">
						</div>
						<p id="image_description">Рисунок 2 – Демонстрация неоптимальное назначение потоков процессорам устройства</p>
					</li>
					<li>
						<p>4. Тепловая нагрузка. Когда устройства перегреваются, они могут тормозить процессор и/или графический процессор, и это может неожиданным образом повлиять на игры. Игры, которые включают сложную графику, тяжелые вычисления или устойчивую сетевую активность, с большей вероятностью столкнутся с проблемами. Используйте тепловой API, чтобы отслеживать изменения температуры на устройстве и принимать меры для поддержания более низкого энергопотребления и более низкой температуры устройства. Когда устройство сообщает о перегреве, прекратите текущую деятельность, чтобы снизить энергопотребление. Например, уменьшите частоту кадров или тесселяцию полигонов.</p>
						<p>Загрузка элементов пользовательского интерфейса. для поддержания постоянной частоты кадров важно учитывать относительно небольшой размер мобильных дисплеев и максимально упростить пользовательский интерфейс.</p>
						<p>Отчет показанный на рисунке 3 [6], является примером фрейма пользовательского интерфейса, который пытается отобразить слишком много элементов по сравнению с возможностями мобильного устройства. Хорошая цель — сократить время обновления пользовательского интерфейса до 2-3 миллисекунд. Таких быстрых обновлений можно добиться, выполнив оптимизацию, подобную следующей:</p>
						<ul class="clear sublevel2">
							<li><p>– Обновлять только те элементы на экране, которые были перемещены;</p></li>
							<li><p>– Ограничить количество текстур и слоев пользовательского интерфейса. Объединить графические вызовы, такие как шейдеры и текстуры, которые используют один и тот же материал;</p></li>
							<li><p>– Перенести операции анимации элементов на GPU;</p></li>
							<li><p>– Выполнить более агрессивное отсечение усеченной пирамиды и окклюзии;</p></li>
							<li><p>– Если возможно, выполнить операции рисования с помощью Vulkan API;</p></li>
							<li><p>– Накладные расходы на вызовы отрисовки ниже на Vulkan.</p></li>
						</ul>
						<div class="image_container flex-center">
							<img src="../images/ui_report.svg" class="responsive_image_20 flex-center">
						</div>
						<p id="image_description">Рисунок 3 – Отчет для игры, в которой одновременно отображаются десятки элементов пользовательского интерфейса.</p>
					</li>
				</ul>

				<h2>Выводы</h2>
				<p>&emsp;Существует огромное количество игровых движков, которые предоставляют программисту много различных функций и позволяют создавать качественные игры, однако если она рассчитана и на пользователей со слабым устройством, то необходимо использовать знания языка программирования, архитектуры движка и операционной системы, чтоб добиться удовлетворительных показателей производительности программы. Для создания подобных проектов необходим большой опыт и немалое количество навыков.</p>
				<p>&emsp;В дальнейших исследованиях планируется проверить на практике приведённые выше методы и представить метрики в виде графиков и диаграмм с целью их усовершенствования.</p><br/>
				<h2>Литература</h2>
				<ul class="links">
					<li>1. Каким должен быть комфортный FPS в играх [Электронный ресурс] – Режим доступа: [<a href="https://andpro.ru/blog/pc/kakim-dolzhen-byt-komfortnyy-fps-v-igrakh/">Перейти</a>]</li>
					<li>2. Почему производительность в играх — это не просто средний FPS [Электронный ресурс] – Режим доступа: [<a href="https://habr.com/ru/company/lesta_studio/blog/265487/">Перейти</a>]</li>
					<li>3. Основы оптимизации кода игр [Электронный ресурс] – Режим доступа: [<a href="https://habr.com/ru/post/358176/">Перейти</a>]</li>
					<li>4. Optimizing your Game [Электронный ресурс] – Режим доступа: [<a href="https://www.reddit.com/r/libgdx/comments/7cw4va/optimizing_your_game/">Перейти</a>]</li>
					<li>5. The LibGDX performance guide [Электронный ресурс] – Режим доступа: [<a href="https://yairm210.medium.com/the-libgdx-performance-guide-1d068a84e181">Перейти</a>]</li>
					<li>6. Best practices for Android game optimization [Электронный ресурс] – Режим доступа: [<a href="https://developer.android.com/games/optimize">Перейти</a>]</li>
				</ul>
			</article>

		</main>
	</body>
</html>