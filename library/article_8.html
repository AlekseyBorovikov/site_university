<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Библиотека</title>
		<link rel="stylesheet" type="text/css" href="../css/style.css">
		<link rel="stylesheet" type="text/css" href="../css/image_style.css">
		<link rel="stylesheet" type="text/css" href="../css/font-style.css">
		<link rel="stylesheet" type="text/css" href="../css/layout-style.css">
		<link rel="stylesheet" type="text/css" href="../css/dimens.css">
		<link rel="stylesheet" type="text/css" href="../css/colors.css">
		<script src="../components/main_inform.js" type="text/javascript" defer></script>
		<script src="../components/header.js" type="text/javascript" defer></script>
		<script src="../components/menu.js" type="text/javascript" defer></script>
		<script src="../components/footer.js" type="text/javascript" defer></script>
	</head>

	<body>
 
 		<div class="back_button"><a href="index.html">&#10094; Назад в библиотеку</a></div>
		
		<main class="flex-center">

			<article>

				<div class="flex-center">
					<div>
						<h2 id="text-align-center">МЕТОДЫ ОПТИМИЗАЦИИ ПРОГРАММ КОМПЬЮТЕРНОЙ ГРАФИКИ OPENGL</h2>
						<p id="text-align-center"><i>Г.В. Князева</i></p>
					</div>
				</div>
				<p id="tab"><i>&emsp;<b>Аннотация: </b> Из своего практического опыта автор показывает, как можно добиться высокого качества визуализации в программе OpenGL.</i></p>
				<p id="tab"><i>&emsp;<b>Ключевые слова: </b>высокоуровневая оптимизация, структуры данных, приложение, интерполяция цветов, векторные версии команд, текстурированные объекты</i></p>
				
				<h2>Организация приложения</h2>
				<p>&emsp;На первый взгляд может показаться, что производительность приложений, основанных на OpenGL, определяется в первую очередь производительностью реализации самой библиотеки OpenGL. Это верно, однако организация всего приложения (использование локальных и глобальных переменных, структур данных, библиотек, последовательность выполнения команд) также очень важна.</p>
				<h2>Высокоуровневая оптимизация</h2>
				<p>&emsp;Обычно от программы под OpenGL требуется визуализация высокого качества на интерактивных скоростях. Но, как правило, и то и другое сразу получить не удается. Следовательно, необходим поиск компромисса между качеством и производительностью. Существует множество различных подходов к данному вопросу:</p>
				<ul class="clear">
					<li><p>– отображение геометрии сцены с низким качеством во время анимации, а в моменты остановок показ ее с наилучшим качеством;</p></li>
					<li><p>– визуализация модели с уменьшенным количеством примитивов во время интерактивного вращения (например, при нажатой клавише мыши) и отображение модели полностью при рисовании статичного изображения;</p></li>
					<li><p>– визуализация модели с уменьшенным количеством примитивов во время интерактивного вращения (например, при нажатой клавише мыши) и отображение модели полностью при рисовании статичного изображения;</p></li>
					<li><p>– объекты, которые находятся полностью вне поля видимости, могут быть эффективно отсечены без передачи на конвейер OpenGL с помощью проверки попадания ограничивающих их простых объемов (сфер или кубов) в пирамиду зрения;</p></li>
					<li><p>– во время анимации можно отключить псевдотонирование (dithering), плавную заливку, наложение текстуры и включать все это во время демонстрации статичных изображений (этот подход особенно эффективен для систем без аппаратной поддержки OpenGL).</p></li>
				</ul>
				<h2>Низкоуровневая оптимизация</h2>
				<p>&emsp;Объекты, отображаемые с помощью OpenGL, хранятся в некоторых структурахданных. Скорость визуализации определяется эффективностью использования таких структур. Желательно, чтобы использовались структуры данных, которые могут быть быстро и эффективно переданы на конвейер OpenGL. Например, если необходимо отобразить массив треугольников, то использование указателя на этот массив значительно более эффективно, чем передача его OpenGL поэлементно.</p>
				<p>&emsp;Предположим, что создается приложение, которое реализует рисование карты местности. Один из компонентов базы данных - список городов с их шириной, долготой и названием.</p>
				<p>Для хранения информации о городе создается соответствующая структура данных. Список городов может храниться как массив таких структур. Затем создается функция, которая рисует города на карте в виде точек разного размера с подписями: если город маленький, то точки имеют размер 2 px, если большой - 4 px.</p>
				<p>Реализация, представленная в первом варианте, неудачна по следующим причинам:</p>
				<ul class="clear">
					<li><p>– glPointSize() вызывается для каждой итерации цикла;</p></li>
					<li><p>– между glBegin() и glEnd() рисуется только одна точка;</p></li>
					<li><p>– вершины определяются в неоптимальном формате.</p></li>
				</ul>
				<p>&emsp;Во втором варианте реализации glPointSize() вызывается только дважды, и увеличивается число вершин между glBegin() и glEnd(). Однако остаются еще пути для оптимизации. Если поменять структуры данных, то можго еще повысить эффективность рисования точек.</p>
				<p>&emsp;Самым оптимальным можно считать третий вариант. После реорганизации структуры города разных размеров хранятся в разных списках, положения точек хранятся отдельно в динамическом массиве. Исключается необходимость в условном операторе внутри glBegin/glEnd и имеется возможность использовать массивы вершин для оптимизации.</p>
				<h2>Оптимизация вызовов opengl</h2>
				<p>&emsp;Существует много возможностей улучшения производительности OpenGL. К тому же разные подходы к оптимизации приводят к разным эффектам при аппаратной и программной визуализации. Например, интерполяция цветов может быть очень дорогой операцией без аппаратной поддержки, а при аппаратной визуализации почти не дает задержек.</p>
				<h2>Передача данных в opengl</h2>
				<p>&emsp;Рассмотрим способы минимизации времени на передачу данных о примитивах в OpenGL.</p>
				<p>&emsp;Использование связанных примитивов, таких как GL_LINE_LOOP, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, и GL_QUAD_STRIP, требует для определения меньше вершин, чем отдельные линии или многоугольник. Это уменьшает количество данных, передаваемых OpenGL.</p>
				<p>&emsp;Использование массивов для передачи параметров в команды может быть очень выигрышным. Вместо использования команд glVertexPointer/glColorPointer/glNormalPointer лучше пользоваться одной командой, как например, glInterleavedArrays (GL_C4F_N3F_V3F, 0, pData);, что означает, что первые четыре float относятся к цвету, затем три float - к нормали, и последние три float задают координаты вершины.</p>
				<p>&emsp;Последовательное расположение данных в памяти улучшает скорость обмена между основной памятью и графической подсистемой.</p>
				<p>&emsp;Использование векторных версий команд glVertex*(), glColor*(), glNormal*() и glTexCoord*(), которые в качестве аргументов принимают указатели (например, glVertex3fv(v)) могут работать значительно быстрее, чем их соответствующие версии glVertex3f(x, y, z).</p>
				<p>&emsp;Уменьшение сложности примитивов при построении поверхностей. Текстурированные объекты, например, могут быть качественно отображены с небольшой сложностью геометрии.</p>
				<p>&emsp;Использование дисплейных списков для наиболее часто выводимых объектов. Дисплейные списки могут храниться в памяти графической подсистемы и, следовательно, исключать частые перемещения данных из основной памяти.</p>
				<p>&emsp;Не следует указывать ненужные атрибуты вершин. Например, если освещение выключено, не нужно вызывать glNormal(); если не используются текстуры, не нужно вызывать glTexCoord(), и т.д.</p>
				<p>&emsp;Минимизация кода между glBegin/glEnd позволяет использовать максимальную производительность графической системы.</p>
				<h2>Преобразования</h2>
				<p>&emsp;Преобразования включают в себя трансформации вершин от координат, указанных в glVertex*(), к оконным координатам, отсечение, освещение и т.д.</p>
				<p>&emsp;Рекомендации по применению освещения:</p>
				<ul class="clear">
					<li><p>– избегайте использования локальных источников света, т.е. координаты источника должны быть в форме (x, y, z, 0);</p></li>
					<li><p>– избегайте использования точечных источников света;</p></li>
					<li><p>– избегайте использования двухстороннего освещения;</p></li>
					<li><p>– избегайте использования отрицательных коэффициентов в параметрах материала и цвета;</p></li>
					<li><p>– избегайте использования локальной модели освещения;</p></li>
					<li><p>– избегайте частой смены параметра материала GL_SHININESS;</p></li>
					<li><p>– можно получить эффект освещения, задавая цвета вершин вместо нормалей;</p></li>
					<li><p>– отключайте нормализацию векторов нормалей, когда это не необходимо -glEnable/Disable(GL_NORMALIZE).</p></li>
				</ul>
				<h2>Растеризация</h2>
				<p>&emsp;Растеризация часто является узким местом программных реализаций OpenGL.</p>
				<p>&emsp;Рекомендации по оптимизации растеризации:</p>
				<ul class="clear">
					<li><p>1. Отключайте интерполяцию цветов, когда в этом нет необходимости. Интерполяция цветов включена по умолчанию. Плоское затенение не требует интерполяции четырех компонент цвета и, как правило, быстрее на программных реализациях OpenGL. Аппаратные реализации обычно выполняют оба вида затенения с одинаковой скоростью. Для отключения используйте команду glShadeModel(GL_FLAT).</p></li>
					<li><p>2. Отключайте тест на глубину, когда в этом нет необходимости. Фоновые объекты, например, могут быть нарисованы без теста на глубину, если они визуализируется первыми.</p></li>
					<li><p>3. Используйте отсечение обратных граней полигонов. Замкнутые объекты могут быть нарисованы с установленным режимом отсечения обратных граней glEnable(GL_CULL_FACE) Иногда это позволяет отбросить до половины многоугольников, не растеризуя их.</p></li>
					<li><p>4. Избегайте лишних операций с пикселями. Маскирование, альфа-смешивание и другие попиксельные операции могут занимать существенное время на этапе растеризации. Отключайте все операции, которые вы не используете.</p></li>
					<li><p>5. Уменьшайте размер окна или разрешение экрана. Простой способ уменьшить время растеризации - уменьшить число пикселей, которые будут нарисованы. Если меньшие размеры окна или меньшее разрешение экрана приемлемы, то это хороший путь для увеличения скорости растеризации.</p></li>
				</ul>
				<h2>Текстурирование</h2>
				<p>&emsp;Наложение текстур является дорогой операцией, как в программных, так и в аппаратных реализациях.</p>
				<p>&emsp;Рекомендации по применению текстурирования:</p>
				<ul class="clear">
					<li><p>1. Используйте эффективные форматы хранения изображений. Формат GL_UNSIGNED_BYTE обычно наиболее всего подходит для передачи текстуры в OpenGL.</p></li>
					<li><p>2. Объединяйте текстуры в текстурные объекты или дисплейные списки. Это особенно важно, если вы используете несколько текстур и позволяет графической подсистеме эффективно управлять размещением текстур в видеопамяти.</p></li>
					<li><p>3. Не используйте текстуры большого размера. Небольшие текстуры быстрее обрабатываются и занимают меньше памяти, что позволят хранить сразу несколько текстур в памяти графической подсистемы.</p></li>
					<li><p>4. Комбинируйте небольшие текстуры в одну. Если вы используете несколько маленьких текстур, можно объединить их в одну большего размера и изменить текстурные координаты для работы с нужной подтекстурой. Это позволяет уменьшить число переключений текстур.</p></li>
					<li><p>5. Анимированные текстуры. Если вы хотите использовать анимированные текстуры, не используйте команду glTexImage2D() чтобы обновлять образ текстуры. Вместо этого используйте glTexSubImage2D() или glTexCopyTexSubImage2D().</p></li>
				</ul>
				<h2>Очистка буферов</h2>
				<p>&emsp;Очистка буферов цвета, глубины, маски и буфера-накопителя может требовать много времени, особенно в программных реализациях OpenGL.</p>
				<p>&emsp;Рекомендации, которые могут помочь оптимизировать эту операцию:</p>
				<ul class="clear">
					<li><p>1. Очищайте все нужные буферы с помощью одной команды glClear(), но используйте эту команду с осторожностью.</p>
					<p>Неверно:</p><br>
						<div class="flex-center">
							<pre class="code">
							<span class="tr first-row"><span class="th"></span><code>glClear(GL_COLOR_BUFFER_BIT);</code></span>
							<span class="tr"><span class="th"></span><code>// очистить буфер маски?</code></span>
							<span class="tr"><span class="th"></span><code>if (stenciling) {</code></span>
							<span class="tr"><span class="th"></span><code>&emsp;glClear(GL_STENCIL_BUFFER_BIT);</code></span>
							<span class="tr"><span class="th"></span><code>}</code></span>
							</pre>
						</div><br/>
						<p>Верно</p><br>
						<div class="flex-center">
							<pre class="code">
							<span class="tr first-row"><span class="th"></span><code>// очистить буфер маски?</code></span>
							<span class="tr"><span class="th"></span><code>if (stenciling) {</code></span>
							<span class="tr"><span class="th"></span><code>&emsp;glClear(GL_COLOR_BUFFER_BIT |STENCIL_BUFFER_BIT);</code></span>
							<span class="tr"><span class="th"></span><code>}</code></span>
							<span class="tr"><span class="th"></span><code>else {</code></span>
							<span class="tr"><span class="th"></span><code>&emsp;glClear(GL_COLOR_BUFFER_BIT);</code></span>
							<span class="tr"><span class="th"></span><code>}</code></span>
							</pre>
						</div><br/>
					</li>
					<li><p>2. Отключайте размывание (dithering) очисткой буфера. Обычно различие между чистками с включенным размыванием и без него незаметно.</p></li>
					<li><p>3. Используйте ножницы (scissors) для очистки меньшей области. Если вы не хотите очищать весь буфер, используйте glScissor() для ограничения очистки по заданной области.</p></li>
					<li><p>4. Не очищайте буфер цвета полностью. Если ваша сцена занимает только часть окна, нет необходимости очищать весь буфер цвета.</p></li>
					<li><p></p></li>
				</ul>
				<h2>Разное</h2>
				<p>&emsp;В данном разделе приведены рекомендации общего характера по оптимизации приложений OpenGL, которые нельзя отнести к какой-либо категории:</p>
				<ul class="clear">
					<li><p>1. Проверяйте ошибки GL во время написания программ. Вызывайте команду glGetError() для проверки, не произошла ли ошибки во время вызова одной из функций OpenGL. Как правило, ошибки возникают из-за неверных параметров команд OpenGL или неверной последовательности команд. Для финальных версий кода отключайте эти проверки, так как они могут существенно замедлить работу. Для проверки можно использовать, например, такой макрос:</p><br>
						<div class="flex-center">
							<pre class="code">
							<span class="tr first-row"><span class="th"></span><code>#include &lt;assert.h></code></span>
							<span class="tr"><span class="th"></span><code>#define CHECK_GL \</code></span>
							<span class="tr"><span class="th"></span><code>assert(glGetError() != GL_NO_ERROR);</code></span>
							<span class="tr"><span class="th"></span><code>// Использовать его можно так:</code></span>
							<span class="tr"><span class="th"></span><code>glBegin(GL_TRIANGLES);</code></span>
							<span class="tr"><span class="th"></span><code>glVertex3f(1,1,1);</code></span>
							<span class="tr"><span class="th"></span><code>glEnd();</code></span>
							<span class="tr"><span class="th"></span><code>CHECK_GL</code></span>
							</pre>
						</div><br/>
					</li>
					<li><p>2. Используйте функцию glColorMaterial() вместо glMaterial(). Если в сцене материалы объектов различаются лишь одним параметром, команда glColorMaterial() может быть быстрее, чем glMaterial().</p></li>
					<li><p>3. Минимизируйте число изменений состояния OpenGL. Команды, изменяющие состояние OpenGL (glEnable/glDisable/glBindTexture и другие), вызывают повторные внутренние проверки целостности, создание дополнительных структур данных и т.д., что может приводить к задержкам.</p></li>
					<li><p>4. Избегайте использования команды glPolygonMode(). Если вам необходимо рисовать много незакрашенных многоугольников, используйте glBegin() с константами GL_POINTS, GL_LINES, GL_LINE_LOOP или GL_LINE_STRIP вместо изменения режима рисования примитивов, так как это может быть намного быстрее.</p></li>
				</ul>
				<p>&emsp;Конечно, эти рекомендации охватывают лишь малую часть возможностей по оптимизации OpenGL-приложений. Тем не менее при их правильном использовании можно достичь существенного ускорения работы программ компьютерной графики OpenGL.</p>
				
				<h2>Литература</h2>
				<ul class="links">
					<li>1. Порев В.Н. Компьютерная графика. - СПб.: BHV, 2002.</li>
					<li>2. Тихомиров Ю. Программирование трехмерной графики. - СПб.: BHV, 1998.</li>
					<li>3. Шикин А. В., Боресков А. В. Компьютерная графика. Полигональные модели. - М.: ДИАЛОГ-МИФИ, 2001.</li>
					<li>4. Эйнджел Э. Интерактивная компьютерная графика. Вводный курс на базе OpenGL. - 2-е изд. / Пер. с англ.- М.: Вильямс, 2001.</li>
				</ul>
			</article>

		</main>
	</body>
</html>