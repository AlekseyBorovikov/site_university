<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Реферат</title>
		<link rel="stylesheet" type="text/css" href="../css/style.css">
		<link rel="stylesheet" type="text/css" href="../css/image_style.css">
		<link rel="stylesheet" type="text/css" href="../css/font-style.css">
		<link rel="stylesheet" type="text/css" href="../css/layout-style.css">
		<link rel="stylesheet" type="text/css" href="../css/dimens.css">
		<link rel="stylesheet" type="text/css" href="../css/colors.css">
		<script src="../components/main_inform.js" type="text/javascript" defer></script>
		<script src="../components/header.js" type="text/javascript" defer></script>
		<script src="../components/menu.js" type="text/javascript" defer></script>
		<script src="../components/footer.js" type="text/javascript" defer></script>
	</head>

	<body>
		<header>
			<header-content
				style="width: 100%;"
				class="flex-center"
				community_name="Магістри"
				universe_name="ДонНТУ"
				eng-lang="true"
				ru-lang="true"
			></header-content>
		</header>
 
		<main>
			<main-inform-component
				class="flex-center"
				full_name="Боровиков Олексій Іванович"
				faculty="Факультет інтелектуальних систем та програмування"
				department="Кафедра програмної інженерії ім. Л. П. Фельдмана"
				specialization="Профіль «Методи та засоби розробки програмного забезпечення»"
				graduate_work="Оптимізація та підвищення продуктивності ігрових движків для системи android"
				scientific_adviser="Науковий керівник: д.т.н., проф. Зорі Сергій Анатолійович"
			></main-inform-component>


			<div class="scroll-menu flex-center">
				<a href="../indexu.html">Резюме</a>
				<a id="selected">Реферат</a>
			</div>
			
			<div class="content_block flex-center">
				
				<article class="main_content">
					
					<h2>Зміст</h2>

					<ul class="clear">
						<li><a id="content" href="#intro">Введення</a></li>
						<li><a id="content" href="#infl">1. Що впливає на продуктивність</a></li>
						<li><a id="content" href="#ways">2. Способи оптимізації коду</a></li>
						<li><a id="content" href="#java_opt">3. Оптимізація движка на основі мови java</a></li>
						<li><a id="content" href="#opengl_opt">4. Оптимізація на основі openGL</a></li>
						<li><a id="content" href="#high_level_opt">5. Високорівнева оптимізація</a></li>
						<li><a id="content" href="#low_level_opt">6. Низькорівнева оптимізація</a></li>
						<li><a id="content" href="#engine_opt">7. Оптимізація ігор для смартфонів</a></li>
						<li><a id="content" href="#cons">Висновок</a></li>
						<li><a id="content" href="#links">Список джерел</a></li>
					</ul>

					<a name="intro"></a>
					<h2 name="">Введення</h2>

					<p>&emsp;Продуктивність є важливим компонентом будь-якої гри, від неї залежить популярність гри, комфорт користувача і загальне враження <a id="content" href="#links">[1]</a>. Під продуктивністю зазвичай мають на увазі середній рівень FPS в грі за певний проміжок часу.  FPS (Frames per Second) - число кадрів в секунду, кадри - це зображення, які обробляє графічний адаптер по команді центрального процесора. Чим більше кадрів демонструється в секунду, тим плавніше і комфортніше гра.</p>

					<p>&emsp;Всупереч очікуванням небагато гравців вимагають високих показників фпс, для більшості досить середніх показників в 30 одиниць, а для деяких навіть менше. Дослідження пророблені компанією Lesta Studio, показують, що для всієї сукупності користувачів зв'язок між продуктивністю і комфортною грою досить слабка (рис.1).</p>

					<div class="image_container flex-center">
						<img src="../images/comfort_fps.png" class="responsive_image_80 flex-center">
					</div>
					<p id="image_description">Рисунок 1-Діаграма залежності між сприйняттям комфорту та середнім FPS</p>

					<p>&emsp;Однак рівень комфорту залежить також від жанру гри і від самого користувача. Наприклад, багато консольні ігри працюють на частоті 30fps, але з такими показниками картинка недостатньо плавна, а відгук на маніпуляції гравця запізнюється, що заважає повному зануренню в гру. Для гравців в казуально-аркадні ігри буде досить 40 + fps, для шутерів від першої особи, стратегій, ритм-ігор, MOBA знадобиться близько 60-100fps <a id="content" href="#links">[2]</a>. Показник FPS вище 100 буде потрібно гравцям змагальних шутерів або кіберспортсменів.</p>

					<p>&emsp;Таким чином, якщо не брати до уваги переваги в fps професійних гравців, то для більшості буде комфортним середній показник в 60fps, цей показник вважається комфортним мінімумом.</p>

					<a name="infl"></a>
					<h2>Що впливає на продуктивність? <a id="content" href="#links">[3]</a></h2>
					<p>Розглянемо найпопулярніші фактори, що впливають на оптимізацію</p><br/>
					<div class="image_container flex-center" id="anim">
						<img src="../images/anim.gif" class="responsive_image_50 flex-center">
					</div>
					<p id="image_description">Основні фактори, що впливають на оптимізацію</p><br>

					<ol class="styled">
						<li class="styled"><span class="title">Клієнтське ПЗ</span>
							<div class="description">
								Якщо система завантажена фоновими процесами або запущені програми, що звертаються до диска під час гри, то ресурсів для самої гри може виявитися недостатньо.
							</div>
						</li>
						<li><span class="title">Конфігурація ПК</span> 
							<div class="description">Від комплектуючих комп'ютера безпосередньо залежить продуктивність.</div>
						</li>
						<li><span class="title">Налаштування графіки</span>
							<div class="description">Графіку налаштовують користувачі зазвичай самі або використовують пресети, проте ні той ні інший варіант не є гарантією того, що настройки будуть виставлені максимально оптимально, через що користувач втрачає продуктивність.</div></li>
						<li><span class="title">Проблеми мережі</span>
							<div class="description">Клієнт-серверна взаємодія не завжди стійко, нерідко у користувачів виникають проблеми з мережею, що впливає на продуктивність мережевих ігор. Причиною цього можуть послужити проблеми на стороні провайдера, велика кількість бездротових клієнтів неоптимальний мережевий маршрут доставки трафіку, неякісної мережеве обладнання.</div>
						</li>
						<li><span class="title">Модифікації</span>
							<div class="description">Модифікації оригінальної гри сторонніми розробниками негативно впливають на продуктивність. Вони не тільки знижують середній fps, але і створюють різкі провали в тих випадках, де чистий клієнт працює стабільно.</div>
						</li>
						<li><span class="title">Швидкість роботи програми</span>
							<div class="description">Існує величезна кількість різних ігрових движків зі своїми плюсами і мінусами, всі вони споживають різну кількість ресурсів, в залежності від якості архітектури і підтримуваних ефектів. Впливає також і мова програмування, на якому написаний движок, тому що в різних мовах ресурси розподіляються по різному. Про це і піде мова далі.</div>
						</li>
					</ol>

					<a name="ways"></a>
					<h2>Способи оптимізації коду</h2>

					<p>&emsp;Для того, щоб движок видавав максимальну кількість fps необхідно не тільки вміти з ним ефективно працювати, але і знати тонкощі розробки мовою, на якому написаний движок, і принципи роботи движка для кращого розуміння процесу розподілу ресурсів. <a id="content" href="#links">[4]</a></p>

					<p>&emsp;Існує багато різних факторів, що впливають на швидкість обробки кадрів, розглянемо загальні методи оптимізації коду. Які можуть підійти практично в будь-якій ситуації:</p>

					<ol class="styled">
						<li><span class="title">Мінімізація впливу об'єктів за межами екрану</span>
							<div class="description">Мінімізація обсягу обчислень за допомогою оптимізації відтворення об'єктів надзвичайно важлива. Найчастіше цим займаються движки, або ж графічний процесор. Для реалізації необхідно розділити об'єкт на 2 шари - перший буде графічним поданням об'єкта, а другий - даними і функціями. Таким чином, якщо об'єкт знаходиться за межами екрану - нам більше не потрібно його малювати.</div>
						</li>
						<li><span class="title">Незалежність від оновлення кадрів</span>
							<div class="description">Зазвичай в ігрових движках більшість об'єктів оновлюються в кожному кадрі, це сильно навантажує процесор і знижує продуктивність. Необхідно, по можливості, позбутися від оновлення в кожному кадрі. Для цього необхідно відокремити функцію рендеринга і викликати її тільки при зміні стану об'єкта.</div>
						</li>
						<li><span class="title">Безпосередні обчислення і пошук значень</span>
							<div class="description">Непогану надбавку до продуктивності може дати хешування тригонометричних функцій, тому що ефективніше зберігати велику таблицю і брати дані з неї, а не виконувати розрахунки на льоту.</div>
						</li>
						<li><span class="title">Час простою</span>
							<div class="description">Необхідно виділити функції, які не залежать від часу, наприклад погодні умови і обчислювати їх, коли користувач відійшов, зайнятий читанням або іншими не витратними до ресурсів речами. Час яке звільняється, коли користувач зайнятий речами не навантажують процесор, можна використовувати для обчислення безлічі інших подій.</div>
						</li>
					</ol>

					<a name="java_opt"></a>
					<h2>Оптимізація движка на основі мови java</h2>

					<p>&emsp;Так само не зайвим буде згадати оптимізацію коду, спираючись на особливості мови програмування java і особливості роботи з движками на його основі <a id="content" href="#links">[5]</a>:</p>

					<ol class="styled">
						<li><span class="title">Цикли</span> 
							<div class="description">Якщо вам необхідно обійти великий масив даних, наприклад список прямокутників (для рендеринга), ворогів або будь-яких інших важких об'єктів і ви збираєтеся для цього використовувати цикл for, то краще пользовться зворотним for. Зворотний for дає більшу ефективність за рахунок того, що йому не потрібно кожен раз перевіряти розмір масиву, а також це відбувається, тому що порівняння з нулем є нормальним, в той час як порівняння з цілим числом вимагає віднімання. Але якщо немає необхідності використовувати цикл for, то більш ефективним буде while.</div>
						</li>
						<li><span class="title">Потоки</span>
							<div class="description">Необхідно розділяти важкі дії на різні потоки і не запускати складну логіку в потоці відтворення. Під час профілювання процесора ви побачите потік з назвою GLThread. Більшість двигунів використовують GL 2.0 / 3.0 для візуалізації, і це потік, який містить контекст GL. Це означає, що кожна зміна інтерфейсу користувача повинна здійснюватися через цей потік, інакше трапляються погані речі — текстури не завантажуються, елементи інтерфейсу змінюються одночасно з різних місць, це може бути безлад. Проблема полягає в тому, що використання цього потоку залишає користувача із завислим додатком.</div>
						</li>
						<li><span class="title">Пам'ять</span>
							<div class="description">Не варто забувати очищати компоненти, які вже не потрібні. Java має власний збирач сміття, який очищає непотрібні класи, але деякі двигуни, такі як libGDX, цього не роблять. Це пов'язано з тим, що пам'ять OpenGL не управляється JVM GC, і, отже, якщо ви створюєте власні текстури, вам доведеться видаляти їх вручну, інакше ви ризикуєте важко налагоджуваним витоком пам'яті.</div>
						</li>
						<li><span class="title">Пакети</span>
							<div class="description">Виклик початку і кінця пакета спрайтів і ShapeRenderer займає багато пам'яті. Отже, намагайтеся з усіх сил викликати початок і кінець тільки один раз за кадр. Спробуйте візуалізувати всі свої спрайти, а потім візуалізувати фігури. Замість того, щоб рендерити ваші спрайти, потім форми, а потім повторно відкриваючи ваш spritebatch.</div>
						</li>
						<li><span class="title">Окремі методи</span>
							<div class="description">Є деякі методи, які вимагають багато ресурсів (або більше, ніж інші), коли вони використовуються, наприклад перетини класу Rectangle. Наприклад, найкраще, що ви можете зробити для перегляду масиву прямокутників, — це спочатку перевірити, чи близькі обидва прямокутники, і якщо так, то викликати метод Intersects для них. Замість виклику Intersects з усіма прямокутниками в масиві.</div>
						</li>
						<li><span class="title">Візуалізація</span>
							<div class="description">Метод малювання-це ще один елемент, який вимагає великої кількості ресурсів, якщо вам потрібно змінити стан елемента, навіть якщо він знаходиться поза екраном, ви можете щоразу намагатися оновлювати його логіку/змінні, але викликати метод малювання лише якщо він знаходиться всередині координат екрана.</div>
						</li>
						<li><span class="title">Змінні</span>
							<div class="description">Оголошення змінних або об'єктів у поганих місцях може спричинити зависання, уникати оголошення змінних у циклі візуалізації та, в основному, не оголошувати їх всередині чогось на зразок циклу for, натомість оголошувати їх поза циклом та оновлювати його значення всередині. Хороший момент у цьому полягає в тому, що це не має значення, коли ми говоримо про примітивні типи даних, тому, якщо змінна має тип int, boolean або float, її оголошення всередині циклу не матиме великого впливу на продуктивність.</div>
						</li>
						<li><span class="title">Патерни</span>
							<div class="description">Патерни значно спрощують розробку і ефективність додаток, а також підтримку коду. Якщо ви хочете мати один елемент, який може взаємодіяти і перебувати в будь-якому класі вашої програми, щось всюдисуще, наприклад клас гравця, ви можете зробити його класом Singleton (це дуже просто і дасть вам більш зручний код). Якщо ви не хочете, щоб у вашій програмі були марні екземпляри, які, можливо, ви ніколи не будете використовувати, ви можете використовувати шаблон дизайну Factory.</div>
						</li>
					</ol>

					<a name="opengl_opt"></a>
					<h2>Оптимізація на основі openGL</h2>
					<p>&emsp;На перший погляд може здатися, що продуктивність додатків, заснованих на OpenGL, визначається в першу чергу продуктивністю реалізації самої бібліотеки OpenGL <a id="content" href="#links">[6]</a>. Це вірно, однак організація всього додатка (використання локальних і глобальних змінних, структур даних, бібліотек, послідовність виконання команд) також дуже важлива.</p>
					<a name="high_level_opt"></a>
					<h2>Високорівнева оптимізація</h2>
					<p>&emsp;Зазвичай від програми під OpenGL потрібно візуалізація високої якості на інтерактивних швидкостях. Але, як правило, і те й інше відразу отримати не вдається. Отже, необхідний пошук компромісу між якістю і продуктивністю. Існує багато різних підходів до цього питання <a id="content" href="#links">[7]</a>:</p>
					<ul class="clear">
						<li><p> – відображення геометрії сцени з низькою якістю під час анімації, а в моменти зупинок показ її з найкращою якістю;</p></li>
						<li><p> – об'єкти, які знаходяться повністю поза полем видимості, можуть бути ефективно відсічені без передачі на конвеєр OpenGL за допомогою перевірки потрапляння обмежуючих їх простих обсягів (сфер або кубів) в піраміду зору;</p></li>
						<li><p> – візуалізація моделі зі зменшеною кількістю примітивів під час інтерактивного обертання (наприклад, при натиснутій клавіші миші) і відображення моделі повністю при малюванні статичного зображення;</p></li>
						<li><p> – під час анімації можна відключити псевдотонування (dithering), плавну заливку, накладення текстури і включати все це під час демонстрації статичних зображень (цей підхід особливо ефективний для систем без апаратної підтримки OpenGL).</p></li>
					</ul>
					<a name="low_level_opt"></a>
					<h2>Низькорівнева оптимізація</h2>
					<p>&emsp;Об'єкти, що відображаються за допомогою OpenGL, зберігаються в деяких структурах даних. Швидкість візуалізації визначається ефективністю використання таких структур. Бажано, щоб використовувалися структури даних, які можуть бути швидко і ефективно передані на конвеєр OpenGL. Наприклад, якщо необхідно відобразити масив трикутників, то використання покажчика на цей масив значно більш ефективно, ніж передача його OpenGL поелементно.</p>
					<p>&emsp;Припустимо, що створюється додаток, який реалізує малювання карти місцевості. Один з компонентів бази даних-список міст з їх шириною, довготою і назвою.</p>
					<p>&emsp;Для зберігання інформації про місто створюється відповідна структура даних. Список міст може зберігатися як масив таких структур. Потім створюється функція, яка малює міста на карті у вигляді точок різного розміру з підписами: якщо місто маленьке, то точки мають розмір 2 px, якщо великий - 4 px.</p>
					<p>&emsp;Реалізація, представлена в першому варіанті, невдала з наступних причин:</p>
					<ul class="clear">
						<li><p> – glPointSize() викликається для кожної ітерації циклу;</p></li>
						<li><p> – між glBegin() і glEnd() малюється лише одна точка;</p></li>
						<li><p> – вершини визначаються в неоптимальному форматі.</p></li>
					</ul>
					<p>&emsp;У другому варіанті реалізації glPointSize() викликається тільки двічі, і збільшується число вершин між glBegin () і glEnd (). Однак залишаються ще шляхи для оптимізації. Якщо поміняти структури даних, то можна ще підвищити ефективність малювання точок.</p>
					<p>&emsp;Найоптимальнішим можна вважати третій варіант. Після реорганізації структури міста різних розмірів зберігаються в різних списках, положення точок зберігаються окремо в динамічному масиві. Виключається необхідність в умовному операторі всередині glBegin / glEnd і є можливість використовувати масиви вершин для оптимізації.</p>

					<a name="engine_opt"></a>
					<h2>Оптимізація ігор для смартфонів <a id="content" href="#links">[8]</a></h2>

					<ol class="styled">
						<li><span class="title">Швидкість завантаження</span>
							<div class="description">Гравці хочуть якомога швидше зануритися в дію вашої гри, тому важливо максимально скоротити час завантаження вашої гри. Наступні заходи зазвичай допомагають скоротити час завантаження:
								<p> – Виконати ледачу завантаження. Якщо ви використовуєте однакові активи в послідовних сценах або рівнях гри, завантажуйте ці активи лише один раз.</p>
								<p> – Зменшіть розмір своїх assets. Таким чином, ви можете пов'язати нестиснуті версії цих ресурсів з APK вашої гри.</p>
								<p> – Використовуйте ефективний для диска метод стиснення. Прикладом такого методу є zlib.</p>
							</div>
						</li>
						<li><span class="title">Тримайте потоки з великою кількістю пам'яті на одному процесорі</span>
							<div class="description">На багатьох мобільних пристроях кеші L1 знаходяться на певних процесорах, а кеші L2 — на наборі процесорів, які мають спільний годинник. Щоб максимізувати потрапляння в кеш L1, як правило, найкраще, щоб основний потік вашої гри, поряд з будь-якими іншими потоками з великим обсягом пам'яті, виконувався на одному процесорі.</div>
						</li>
						<li><span class="title">Відкладайте короткочасну роботу на процесори з меншою потужністю</span>
							<div class="description">Більшість ігрових двигунів вміють відкладати операції робочого потоку на інший процесор порівняно з основним потоком вашої гри. Однак движок не знає про конкретну архітектуру пристрою і не може передбачити робоче навантаження вашої гри так само добре, як Ви <a id="content" href="#links">[9]</a>. Більшість пристроїв типу "система на чіпі" мають принаймні 2 Загальні тактові генератори. один для швидких процесорів пристрою та один для повільних процесорів пристрою. Наслідком цієї архітектури є те, що якщо одному швидкому процесору потрібно працювати на максимальній швидкості, всі інші швидкі процесори також працюють на максимальній швидкості. У прикладі звіту, показаному на рис. 2, показана гра, яка використовує переваги швидких процесорів. Однак, цей високий рівень активності швидко генерує велику кількість енергії і тепла.
							
								<div class="image_container flex-center">
									<img src="../images/cpu_report.svg" class="responsive_image_80 flex-center">
								</div>
								<p id="image_description">Малюнок 2-демонстрація неоптимальне призначення потоків процесорам пристрою</p>
							</div>
						</li>
						<li><span class="title">Теплове навантаження</span>
							<div class="description">Коли пристрої перегріваються, вони можуть гальмувати процесор та/або графічний процесор, і це може несподівано вплинути на ігри. Ігри, які включають складну графіку, важкі обчислення або стійку мережеву активність, частіше стикаються з проблемами. Використовуйте тепловий API, щоб відстежувати зміни температури на пристрої і вживати заходів для підтримки більш низького енергоспоживання і більш низької температури пристрою. Коли пристрій повідомляє про перегрів, припиніть поточну діяльність, щоб знизити енергоспоживання. Наприклад, зменшіть частоту кадрів або тесселяцію багатокутників.
							<br/><br/>Завантаження елементів інтерфейсу користувача. для підтримки постійної частоти кадрів важливо враховувати відносно невеликий розмір мобільних дисплеїв і максимально спростити користувальницький інтерфейс.
							<br/><br/>Звіт показаний на малюнку 3, є прикладом кадру інтерфейсу користувача, який намагається відобразити занадто багато елементів у порівнянні з можливостями мобільного пристрою. Хороша мета-скоротити час оновлення інтерфейсу користувача до 2-3 мілісекунд. Таких швидких оновлень можна досягти, виконавши оптимізацію, подібну до наступної:
							
							<p>– Оновлювати тільки ті елементи на екрані, які були переміщені.</p>
							<p>– Обмежте кількість текстур та шарів інтерфейсу користувача. Об'єднати Графічні виклики, такі як шейдери і текстури, які використовують один і той же матеріал.</p>
							<p>– Перенести операції анімації елементів на GPU.</p>
							<p>– Виконати більш агресивне відсікання усіченої піраміди і оклюзії.</p>
							<p>– Якщо можливо, виконати операції малювання за допомогою vulcan API.</p>
							<p>– Накладные расходы на вызовы отрисовки ниже на Vulkan. <a id="content" href="#links">[10]</a></p>

							<div class="image_container flex-center">
								<img src="../images/ui_report.svg" class="responsive_image_20 flex-center">
							</div>
							<p id="image_description">Рісунок 3-Звіт для гри, в якій одночасно відображаються десятки елементів користувальницького інтерфейсу.</p>
							</div>
						</li>
					</ol>

					<a name="cons"></a>
					<h2>Висновок</h2>
					<p>&emsp;Існує величезна кількість ігрових движків, які надають програмісту багато різних функцій і дозволяють створювати якісні ігри, однак якщо вона розрахована на користувачів зі слабким пристроєм, то необхідно використовувати знання мови програмування, архітектури движка і операційної системи, щоб домогтися задовільних показників продуктивності програми. Для створення подібних проектів необхідний великий досвід і чимала кількість навичок.</p>
					<p>&emsp;У подальших дослідженнях планується перевірити на практиці наведені вище методи і представити метрики у вигляді графіків і діаграм з метою їх удосконалення.</p>

					<a name="links"></a>
					<h2>Список джерел</h2>

					<ul class="clear">
						<li><a id="content" href="https://andpro.ru/blog/pc/kakim-dolzhen-byt-komfortnyy-fps-v-igrakh/">1. Каким должен быть комфортный FPS в играх [Електронний ресурс] – Режим доступу: https://andpro.ru/blog/pc/kakim-dolzhen-byt-komfortnyy-fps-v-igrakh/</a></li>
						<li><a id="content" href="https://habr.com/ru/company/lesta_studio/blog/265487/">2. Почему производительность в играх — это не просто средний FPS [Електронний ресурс] – Режим доступу: https://habr.com/ru/ company/lesta_studio/blog/265487/</a></li>
						<li><a id="content" href="https://habr.com/ru/post/358176/">3. Основы оптимизации кода игр [Електронний ресурс] – Режим доступу: https://habr.com/ru/post/358176/</a></li>
						<li><a id="content" href="https://www.reddit.com/r/libgdx/comments/7cw4va/optimizing_your_game/">4. Optimizing your Game [Електронний ресурс] – Режим доступу: https://www.reddit.com/r/libgdx/comments /7cw4va/optimizing_your_game/</a></li>
						<li><a id="content" href="https://yairm210.medium.com/the-libgdx-performance-guide-1d068a84e181">5. The LibGDX performance guide [Електронний ресурс] – Режим доступу: https://yairm210.medium.com/the-libgdx-performance-guide-1d068a84e181</a></li>
						<li><a id="content" href="https://www.khronos.org/opengl/">6. OpenGL Documentation [Electronic resource] – https://www.khronos.org/opengl/</a></li>
						<li><a id="content" href="https://cyberleninka.ru/article/n/metody-optimizatsii-pod-opengl">7. Методы оптимизации под OpenGL [Електронний ресурс] – https://cyberleninka.ru/article/n/metody-optimizatsii-pod-opengl</a></li>
						<li><a id="content" href="https://developer.android.com/games/optimize">8. Best practices for Android game optimization [Електронний ресурс] – Режим доступу: https://developer.android.com /games/optimize</a></li>
						<li><a id="content" href="http://www.libgdx.ru/2013/08/introduction.html">9. libGDX - фреймворк для разработки игр [Електронний ресурс] – Режим доступу: http://www.libgdx.ru/2013 /08/introduction.html</a></li>
						<li><a id="content" href="https://www.vulkan.org">10. Vulkan [Електронний ресурс] – Режим доступу: https://www.vulkan.org</a></li>
					</ul>
				
				</article>
				
			</div>
			
		</main>

		<footer class="flex-center">
	      <footer-content contacts_caption="Контакти"></footer-content>
	    </footer>
	</body>
</html>